/*
 * This source file was generated by the Gradle 'init' task
 */
package test;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;

import org.mysql.*;
import org.models.*;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSet;
import java.time.LocalDate;
import java.util.List;
import java.util.ArrayList;


class SQLConnection {
    private Connection bddConnection;
    private Database database;

    @Test void testMySQLConnection() throws SQLException {
        bddConnection = DatabaseConnection.getConnection(new TestCredentials());
        database = new TestDatabase();
        assertInstanceOf(Connection.class, bddConnection);
    }
}


class MySQLTest {
    private Connection bddConnection;
    private Database database;

    @BeforeEach
    void setUp() throws SQLException {
        bddConnection = DatabaseConnection.getConnection(new TestCredentials());
        database = new TestDatabase();
    }

    @AfterEach
    void cleanUp() throws SQLException {
        String sql = "DROP TABLE " + database.tableName;
        bddConnection.createStatement().execute(sql);
    }

    @Test void testTableCreation() {
        try {
            createTable();
            checkIfTableCreated();
        } catch (SQLException e){
            e.printStackTrace();
        }
    }

    private void createTable() throws SQLException {
        TableCreation tableCreation = new TableCreation(bddConnection, database);
        tableCreation.chooseDatabase();
        tableCreation.createTaskTable();
    }

    private void checkIfTableCreated() throws SQLException {
        Statement statement = bddConnection.createStatement();
        ResultSet resultSet = statement.executeQuery("SHOW TABLES");
        Boolean found = false;
        while (resultSet.next()){
            String tableName = resultSet.getString(1);
            if ("tasks".equals(tableName)){
                found = true;
            }
        }
        assertTrue(found);
    }

    @Test void testSQLRegister(){
        try {
            createTable();
            Task task = new Task("test 1", LocalDate.of(2025, 6, 4));
            register(task);
            checkIfTaskRegistered(task);
        } catch (SQLException e){
            e.printStackTrace();
        }
    }

    private void register(Task... tasks) throws SQLException {
        SQLRegisterTask registerTask = new SQLRegisterTask(bddConnection, database);
        for (Task task:tasks){
            registerTask.register(task);
        }
    }

    private void checkIfTaskRegistered(Task task) throws SQLException {
        Statement statement = bddConnection.createStatement();
        ResultSet resultSet = statement.executeQuery("SELECT id, task, created_at FROM tasks");
        while (resultSet.next()){ 
            assertEquals(1, resultSet.getInt("id"));
            assertEquals(task.getText(), resultSet.getString("task"));
            assertEquals(task.getDate().toString(), resultSet.getDate("created_at").toString());
        }
    }    

    @Test void testSQLExtractAllTasks(){
        try {
            createTable();
            Task task = new Task("test 1", LocalDate.of(2025, 6, 4));
            register(task);
            List<Task> taskList = extractTask("allTasks");
            checkExtraction(task, taskList);
        } catch (SQLException e){
            e.printStackTrace();
        }
    }

    private List<Task> extractTask(String label) throws SQLException {
        ExtractSQLData sqlData = new ExtractSQLDataFactory(label, bddConnection, database).chooseSQLData();
        return sqlData.getData();
    }

    private void checkExtraction(Task task, List<Task> taskList){
        Task resultingTask = taskList.get(0);
        assertEquals(1, taskList.size());
        assertEquals(1, resultingTask.getId());
        assertEquals(task.getText(), resultingTask.getText());
        assertEquals(task.getDate().toString(), resultingTask.getDate().toString());    
    }

    @Test void testDeleteTask() {
        try{
            createTable();
            Task task = new Task("test 1", LocalDate.of(2025, 6, 4));
            Task task2 = new Task("test 2", LocalDate.of(2025, 6, 5));
            register(task, task2);
            deleteTaskNumber(1);
            checkExtractionAfterDeleteFirstTask(task2);
        } catch (SQLException e){
            e.printStackTrace();
        }      
    }

    private void deleteTaskNumber(Integer id) throws SQLException {
        DeleteTask deleteObject = new DeleteTask(id, bddConnection, database);
        deleteObject.delete();
    }

    private void checkExtractionAfterDeleteFirstTask(Task task2) throws SQLException {
        List<Task> taskList = extractTask("allTasks");
        Task resultingTask = taskList.get(0); 
        assertEquals(1, taskList.size());
        assertEquals(2, resultingTask.getId());
        assertEquals(task2.getText(),  resultingTask.getText());
        assertEquals(task2.getDate().toString(), resultingTask.getDate().toString());
    }
}
